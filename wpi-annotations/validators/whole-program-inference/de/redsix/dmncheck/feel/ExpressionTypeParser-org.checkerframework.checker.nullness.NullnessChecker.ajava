package de.redsix.dmncheck.feel;

import de.redsix.dmncheck.result.ValidationResult;
import de.redsix.dmncheck.util.Either;
import de.redsix.dmncheck.util.Eithers;
import org.camunda.bpm.model.dmn.instance.ItemDefinition;
import org.camunda.bpm.model.dmn.instance.NamedElement;
import org.jparsec.Parser;
import org.jparsec.Parsers;
import org.jparsec.Scanners;
import org.jparsec.Terminals;
import org.jparsec.Tokens;
import org.jparsec.error.ParserException;
import org.jparsec.pattern.Patterns;
import java.util.Collection;
import java.util.Objects;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
public final class ExpressionTypeParser {

    @org.checkerframework.dataflow.qual.SideEffectFree
    private ExpressionTypeParser() {
    }

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<Void> IGNORED = Scanners.WHITESPACES.skipMany();

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<?> TOKENIZER(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Collection<ItemDefinition> itemDefinitions) {
        final Parser<?> itemDefinitionTokenizer = itemDefinitions.stream().map(NamedElement::getName).filter(Objects::nonNull).map(name -> Patterns.string(name).toScanner("itemDefinition").source().map(s -> Tokens.fragment(s, "itemDefinitionFragment"))).reduce(Parsers.never(), Parsers::or);
        return Parsers.or(Patterns.stringCaseInsensitive("string").toScanner("string").source().map(s -> Tokens.fragment(s, "stringfragment")), Patterns.stringCaseInsensitive("boolean").toScanner("boolean").source().map(s -> Tokens.fragment(s, "booleanfragment")), Patterns.stringCaseInsensitive("integer").toScanner("boolean").source().map(s -> Tokens.fragment(s, "integerfragment")), Patterns.stringCaseInsensitive("long").toScanner("boolean").source().map(s -> Tokens.fragment(s, "longfragment")), Patterns.stringCaseInsensitive("double").toScanner("boolean").source().map(s -> Tokens.fragment(s, "doublefragment")), Patterns.stringCaseInsensitive("date").toScanner("boolean").source().map(s -> Tokens.fragment(s, "datefragment")), itemDefinitionTokenizer, Patterns.regex("([a-z][a-z_0-9]*\\.)*[A-Z_]($[A-Z_]|[\\w_])*").toScanner("enum").source().map(s -> Tokens.fragment(s, "enumfragment")));
    }

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> STRING = Terminals.fragment("stringfragment").map(__ -> ExpressionTypes.STRING());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> BOOLEAN = Terminals.fragment("booleanfragment").map(__ -> ExpressionTypes.BOOLEAN());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> INTEGER = Terminals.fragment("integerfragment").map(__ -> ExpressionTypes.INTEGER());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> LONG = Terminals.fragment("longfragment").map(__ -> ExpressionTypes.LONG());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> DOUBLE = Terminals.fragment("doublefragment").map(__ -> ExpressionTypes.DOUBLE());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> DATE = Terminals.fragment("datefragment").map(__ -> ExpressionTypes.DATE());

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> ENUM = Terminals.fragment("enumfragment").map(ExpressionTypes::ENUM);

    private static final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> TOP = Parsers.EOF.map((__) -> ExpressionTypes.TOP());

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> ITEMDEFINITION(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Collection<ItemDefinition> itemDefinitions) {
        return Terminals.fragment("itemDefinitionFragment").map(name -> {
            final ItemDefinition matchedItemDefinition = itemDefinitions.stream().filter(itemDefinition -> name.equals(itemDefinition.getName())).findFirst().orElseThrow(() -> new IllegalStateException("ItemDefinitions are broken."));
            return ExpressionTypes.ITEMDEFINITION(matchedItemDefinition);
        });
    }

    static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Parser<ExpressionType> PARSER(@org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Collection<ItemDefinition> itemDefinitions) {
        return Parsers.or(STRING, BOOLEAN, INTEGER, LONG, DOUBLE, DATE, ITEMDEFINITION(itemDefinitions), ENUM, TOP).from(TOKENIZER(itemDefinitions), IGNORED);
    }

    public static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> parse(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull CharSequence charSequence, @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Collection<ItemDefinition> itemDefinitions) {
        try {
            return Eithers.right(charSequence != null ? PARSER(itemDefinitions).parse(charSequence) : ExpressionTypes.TOP());
        } catch (final ParserException e) {
            return Eithers.left(ValidationResult.init.message("Could not parse FEEL expression type '" + charSequence + "'"));
        }
    }
}
