package de.redsix.dmncheck.feel;

import de.redsix.dmncheck.result.Severity;
import de.redsix.dmncheck.result.ValidationResult;
import de.redsix.dmncheck.util.Either;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
import static de.redsix.dmncheck.util.Eithers.left;
import static de.redsix.dmncheck.util.Eithers.right;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.NullnessChecker")
public final class FeelTypecheck {

    @org.checkerframework.dataflow.qual.SideEffectFree
    private FeelTypecheck() {
    }

    public final static class Context extends HashMap<String, ExpressionType> {
    }

    public static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheck(final FeelExpression expression) {
        return typecheck(new Context(), expression);
    }

    public static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheck(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Context context, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression expression) {
        return FeelExpressions.caseOf(expression).<// FIXME: 12/10/17 The explicit type is needed as otherwise the type of 'right' is lost.
        Either<ValidationResult.Builder.ElementStep, ExpressionType>>Empty_(right(ExpressionTypes.TOP())).Null_(right(ExpressionTypes.TOP())).BooleanLiteral(bool -> right(ExpressionTypes.BOOLEAN())).DateLiteral(dateTime -> right(ExpressionTypes.DATE())).DoubleLiteral(aDouble -> right(ExpressionTypes.DOUBLE())).IntegerLiteral(integer -> right(ExpressionTypes.INTEGER())).StringLiteral(string -> right(ExpressionTypes.STRING())).VariableLiteral(name -> {
            if (context.containsKey(name)) {
                return right(context.get(name));
            } else {
                return left(ValidationResult.init.message("Variable '" + name + "' has no type.").severity(Severity.WARNING));
            }
        }).RangeExpression((__, lowerBound, upperBound, ___) -> typecheckRangeExpression(context, lowerBound, upperBound)).UnaryExpression((operator, operand) -> typecheckUnaryExpression(context, operator, operand)).BinaryExpression((left, operator, right) -> typecheckBinaryExpression(context, left, operator, right)).DisjunctionExpression((head, tail) -> typecheckDisjunctionExpression(context, head, tail));
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheckDisjunctionExpression(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Context context, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression head, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression tail) {
        return typecheck(context, head).bind(headType -> typecheck(context, tail).bind(tailType -> check(headType.equals(tailType), "Types of head and tail do not match.").orElse(right(headType))));
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheckBinaryExpression(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Context context, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression left, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Operator operator, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression right) {
        return typecheck(context, left).bind(leftType -> typecheck(context, right).bind(rightType -> check(leftType.equals(rightType), "Types of left and right operand do not match.").orElse(checkOperatorCompatibility(leftType, operator))));
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheckUnaryExpression(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Context context, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Operator operator, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression operand) {
        final Stream<Operator> allowedOperators = Stream.of(Operator.GT, Operator.GE, Operator.LT, Operator.LE, Operator.NOT, Operator.SUB);
        return typecheck(context, operand).bind(type -> check(allowedOperators.anyMatch(operator::equals), "Operator is not supported in UnaryExpression.").orElse(checkOperatorCompatibility(type, operator)));
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> checkOperatorCompatibility(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull ExpressionType type, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Operator operator) {
        switch(operator) {
            case GE:
            case GT:
            case LE:
            case LT:
            case DIV:
            case EXP:
            case MUL:
            case ADD:
            case SUB:
                return check(ExpressionType.isNumeric(type), "Operator " + operator + " expects numeric type but got " + type).orElse(right(type));
            case OR:
            case AND:
                return check(ExpressionTypes.BOOLEAN().equals(type), "Operator " + operator + " expects boolean but got " + type).orElse(right(type));
            case NOT:
                return right(type);
            default:
                return left(ValidationResult.init.message("Unexpected operand " + operator));
        }
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Either<ValidationResult.Builder.ElementStep, ExpressionType> typecheckRangeExpression(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Context context, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression lowerBound, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull FeelExpression upperBound) {
        final List<ExpressionType> allowedTypes = Arrays.asList(ExpressionTypes.INTEGER(), ExpressionTypes.DOUBLE(), ExpressionTypes.LONG(), ExpressionTypes.DATE());
        return typecheck(context, lowerBound).bind(lowerBoundType -> typecheck(context, upperBound).bind(upperBoundType -> check(lowerBoundType.equals(upperBoundType), "Types of lower and upper bound do not match.").or(() -> check(allowedTypes.contains(lowerBoundType), "Type is unsupported for RangeExpressions.")).orElse(right(lowerBoundType))));
    }

    private static @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Optional<Either<ValidationResult.Builder.ElementStep, ExpressionType>> check(final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull Boolean condition, final @org.checkerframework.checker.initialization.qual.Initialized @org.checkerframework.checker.nullness.qual.NonNull String errorMessage) {
        if (!condition) {
            final ValidationResult.Builder.SeverityStep validationResult = ValidationResult.init.message(errorMessage);
            return Optional.of(left(validationResult));
        } else {
            return Optional.empty();
        }
    }
}
